//=======1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
//Author information
//  Author name: Floyd Holliday
//  Author email: holliday@fullerton.edu or activeprofessor@yahoo.com
//  Author location: Fullerton, Calif.
//Course information
//  Course number: CPSC240
//  Assignment number: 18
//  Due date: 2015-July-1
//Project information
//  Project title: AVX Demonstration
//  Purpose: This program will use some instructions that apply only to the AVX component.  If these instructions are successful then there is strong reason to believe
//           that the current platform has the AVX component.  There are other compact techniques to test for the presence of the AVX component, but this program also 
//           includes sample instructions accessing AVX data.
//  Status: Executed as expected on both AVX and non-AVX platforms.
//  Project files: avxdriver.c, avxmain.asm, protectdata.inc
//Module information
//  File name: avxdriver.c
//  This module's call name: avx.out  This module is invoked by the user.
//  Language: C
//  Date last modified: 2015-July-2
//  Purpose: This module is the top level driver: it will call testymm
//  File name: testymmdriver.c
//  Status: In production.  No known errors.
//  Future enhancements: None planned
//Translator information (Tested in Linux shell)
//  Gnu compiler: gcc -c -m64 -Wall -std=c99 -l avxdriver.lis -o avxdriver.o avxdriver.c
//  Gnu linker:   gcc -m64 -o avx.out avxdriver.o avxmain.o
//  Execute:      ./avx.out
//References and credits
//  No references: this module is standard C language
//Format information
//  Page width: 172 columns
//  Begin comments: 61
//  Optimal print specification: Landscape, 7 points, monospace, 8Â½x11 paper
//
//===== Background information ============================================================================================================================================
//
//Background: The original 8088 processor performed only integer oprations.  Many computers included the separate 8087 processor known as a floating point coprocessor; the
//8087 performed floating point operations.  Later the two processor were united into a single physical CPU.  The former coprocessor became the FPU of the new CPU.  The
//FPU continues to perform scalar floating point operations.  Due to time limitations the FPU is studied only briefly in CPSC240.  The FPU is also known as State Component
//number zero.
//
//Later a third unit was added to the X86 processor, namely: the SSE2, which means Streaming SIMD Extensions, revision 2.  Here SIMD means Single Instruction Multiple
//Data.  The SSE2 registers are designated by xmm0, xmm1, ... , xmm15.  Each SSE2 register is commonly called a vector, or a vector register.  The use of SIMD instructions
//is often called vector processing.  SSE (regardless of version number) is also known as State Component number one.
//
//In November 2008 Intel released the Core-i7 processor, the first of the Core-i series.  The intriguing feature of the Core-i processors is the inclusion of the AVX or
//Advanced Vector Extensions.  With AVX each of the xmm registers was double and given the name ymm.  For instance the xmm5 register was expanded, and the expanded
//register is named ymm5.  Thus, xmm5 is the lower half of ymm5.  The 16 ymm registers are contained within the AVX component although the lower half of each ymm register
//overlaps with the corresponding xmm register in SSE2.  Each of the AVX registers holds 256 bits or 4 quadword float numbers.  AVX is also known as State Component number
//two.
//
//According to Seyfarth, page 156, all the Core-i processors have the extended AVX registers.  Seyfarth does not state which other processors have the AVX component; 
//however, it can be easily verified online that AMD processors in the bulldozer, steamroller, and piledriver classes do have the AVX component.
//
//Strategy.  This program will execute a few simple AVX instructions.  If the program runs to completion then the processor contains the AVE component.  If the program
//halts with a core dump then the processor does not have AVX.
//
//
//===== Begin code area ===================================================================================================================================================
//
#include <stdio.h>
#include <stdint.h>

extern double assign1();

int main()
{
 printf("%s","This is CPSC 240 Assignment 1 programmed by Justin Stewart.\n");
 assign1();
 //printf("%s %1.12lf\n","The driver received this number: ", return_code);
 printf("%s","The driver program will now return 0 to the operating system.  Have a nice X86 day.\n");
 return 0;
}//End of main


//To Cpsc240 students:  Run this program on your personal computer.  The question you're seeking to answer is: Does my machine support the Advanced Vector Extensions?  In
//other words does my machine have the ymm set of registers where each register has 4 quadword components.  If this program runs to completion in your computer the answer
//is 'yes': your machine has ymm registers.  If the program stops with a core dump, then you do not have ymm registers.  I welcome email messages telling me the CPU in
//your computer and the outcome of running this program.  Mailto: activeprofessor@yahoo.com or holliday@fullerton.edu or both.
//=======1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3=========4=========5=========6=========7**
